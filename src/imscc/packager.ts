import JSZip from "jszip";
import { ImsItem, ImsManifest, ImsResource } from "./manifest/types";
import { manifestXml } from "./manifest/manifest";
import { Attachment, Course, IMS_RESOURCE_TYPES, Module, Page, ResourceType } from "./types";

import { discussionDocument } from "./resource/discussion";
import { htmlDocument } from "./resource/html";

interface ResourceAttachment extends Attachment {
  filePath: string;
}

interface ResourcePage extends Page {
  id: string;
  filePath: string;
  dependencies?: string[];
  attachments?: ResourceAttachment[];
}

interface ResourceModule extends Module {
  pages: ResourcePage[];
}

const randomId = (prefix?: string) => (prefix ? prefix + '_' : '') + Math.random().toString(36).slice(2);

const DOCUMENT_GENERATORS: Record<ResourceType, (page: Page, id: string) => {
  "ext": string;
  "content": string;
}> = {
  "webcontent": htmlDocument,
  "discussion": discussionDocument,
  "weblink": () => { throw new Error("Not implemented") },
  "assessment": () => { throw new Error("Not implemented") },
};

const pageResource = (page: ResourcePage): ImsResource => {
  const type = IMS_RESOURCE_TYPES[page.type];
  let resource: ImsResource;

  if (page.type === "webcontent") {
    resource = {
      identifier: page.id,
      type,
      href: page.filePath,
      file: {
        href: page.filePath
      }
    }
  } else if (page.type === "discussion") {
    resource = {
      identifier: page.id,
      type,
      file: {
        href: page.filePath
      }
    }
  } else {
    throw new Error(`Unsupported page type: ${page.type}`);
  }

  if (page.dependencies) {
    resource.dependencies = page.dependencies;
  }

  return resource;
};

const moduleItem = (module: ResourceModule): ImsItem => ({
  identifier: randomId("MODULE"),
  title: module.title,
  items: module.pages.map((page): ImsItem => ({
    identifier: randomId("PAGE"),
    title: page.title,
    identifierRef: page.id
  }))
});

const FILEBASE_PLACEHOLDER = `%24IMS-CC-FILEBASE%24`;
const CONTENT_DIR = "wiki_content";
const FILES_DIR = "web_resources";

const nextFilePath = (filenames: Set<string>, pathPrefix: string, fileTitle: string, ext: string): string => {
  let filePath = `${pathPrefix}_${fileTitle}.${ext}`;
  let inc = 1;
  while (filenames.has(filePath)) {
    filePath = `${pathPrefix}_${fileTitle}_${inc}.${ext}`;
    inc++;
  }
  filenames.add(filePath);

  return filePath;
}

export const packageCourse = async (courseContent: Course, generatorComment: string = "Generated by IMSCC Packager"): Promise<[JSZip, string]> => {
  const zip = new JSZip();

  const modules: ResourceModule[] = [];

  const contentFiles = new Set<string>();
  const attachmentFiles = new Set<string>();
  const activityFiles = new Set<string>();

  courseContent.modules.forEach((module, i) => {
    const moduleNumber = i + 1;
    const pathPrefix = `module_${moduleNumber}`;

    modules.push({
      title: module.title,
      pages: module.pages.map((page) => {
        const id = page.type === "webcontent" ? randomId("CONTENT") : randomId("ACTIVITY");

        const { ext, content } = DOCUMENT_GENERATORS[page.type](page, id);
        const fileTitle = page.title.replace(/[^a-z0-9]/gi, '-').toLowerCase();

        const filePath = page.type === "webcontent"
          ? `${CONTENT_DIR}/${nextFilePath(contentFiles, pathPrefix, fileTitle, ext)}`
          : nextFilePath(activityFiles, pathPrefix, fileTitle, ext);

        const resourcePage: ResourcePage = {
          title: page.title,
          type: page.type,
          content,
          filePath,
          id,
        };

        if (page.attachments) {
          const resourceAttachments = page.attachments.map((attachment): ResourceAttachment => {
            if (!attachment.placeholder) {
              throw new Error("Attachment must have a placeholder property");
            }
            const placeholder = attachment.placeholder;
            const [attachmentTitle, attachmentExt] = attachment.filename.split('.');
            const attachmentFilePath = nextFilePath(attachmentFiles, pathPrefix, attachmentTitle, attachmentExt);
            const attachmentZipFilePath = `${FILES_DIR}/${attachmentFilePath}`;

            if (attachment.blob) {
              zip.file(attachmentZipFilePath, attachment.blob);
            } else if (attachment.base64) {
              zip.file(attachmentZipFilePath, attachment.base64, { base64: true });
            } else {
              throw new Error("Attachment must have either a blob or base64 property");
            }

            resourcePage.content = resourcePage.content.replaceAll(placeholder, `${FILEBASE_PLACEHOLDER}/${attachmentFilePath}`);

            return {
              ...attachment,
              filePath: attachmentZipFilePath
            };
          });

          resourcePage.attachments = resourceAttachments;
        }

        zip.file(filePath, resourcePage.content);

        return resourcePage;
      })
    });
  });

  const resourcePages: ResourcePage[] = modules.reduce((acc: ResourcePage[], module) => acc.concat(module.pages), []);
  const attachmentResources: ImsResource[] = resourcePages.reduce(
    (acc: ImsResource[], page): ImsResource[] =>
      acc.concat(
        page.attachments ? page.attachments.map(
          (attachment): ImsResource => {
            const id = randomId("MEDIA");

            page.dependencies = page.dependencies || [];
            page.dependencies.push(id);
            return {
              identifier: id,
              type: "webcontent",
              file: {
                href: attachment.filePath
              }
            };
          }
        ) : []
      ),
    []
  );

  const resources = resourcePages.map(pageResource).concat(attachmentResources);

  const manifest: ImsManifest = {
    generatorComment,
    identifier: randomId("COURSE"),
    metadata: {
      title: courseContent.title,
      description: courseContent.description,
      language: courseContent.language || "en"
    },
    organizations: [{
      identifier: randomId("NAV"),
      items: modules.map(moduleItem)
    }],
    resources: resources
  };

  const manifestFileContents = manifestXml(manifest);
  zip.file("imsmanifest.xml", manifestFileContents)

  return [zip, manifestFileContents];
};

export const generateImscc = async (course: Course): Promise<Blob> => {
  const [zip, _manifest] = await packageCourse(course);
  const zipBlob = await zip.generateAsync({ type: "blob" });
  return zipBlob;
}
