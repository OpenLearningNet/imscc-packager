import JSZip from "jszip";
import { ImsItem, ImsManifest, ImsResource } from "./manifest/types";
import { manifestXml } from "./manifest/manifest";
import {
  Attachment,
  Config,
  Course,
  IMS_RESOURCE_TYPES,
  Module,
  Page,
  ResourceType,
} from "./types";

import { discussionDocument } from "./resource/discussion";
import { cssFromConfig, htmlDocument } from "./resource/html";
import { DEFAULT_VERSION, Version } from "./manifest/versions";
import { CONTENT_DIR, FILEBASE_PLACEHOLDER, FILES_DIR } from "./constants";

interface ResourceAttachment extends Attachment {
  filePath: string;
}

interface ResourcePage extends Page {
  id: string;
  filePath: string;
  dependencies?: string[];
  attachments?: ResourceAttachment[];
}

interface ResourceModule extends Module {
  pages: ResourcePage[];
}

const randomId = (prefix?: string) =>
  (prefix ? prefix + "_" : "") + Math.random().toString(36).slice(2);

const DOCUMENT_GENERATORS: Record<
  ResourceType,
  (
    page: Page,
    id: string,
    options?: Config
  ) => {
    ext: string;
    content: string;
  }
> = {
  webcontent: htmlDocument,
  discussion: discussionDocument,
  weblink: () => {
    throw new Error("Not implemented");
  },
  assessment: () => {
    throw new Error("Not implemented");
  },
};

const pageResource = (page: ResourcePage): ImsResource => {
  const type = IMS_RESOURCE_TYPES[page.type];
  let resource: ImsResource;

  if (page.type === "webcontent") {
    resource = {
      identifier: page.id,
      type,
      href: page.filePath,
      file: {
        href: page.filePath,
      },
    };
  } else if (page.type === "discussion") {
    resource = {
      identifier: page.id,
      type,
      file: {
        href: page.filePath,
      },
    };
  } else {
    throw new Error(`Unsupported page type: ${page.type}`);
  }

  if (page.dependencies) {
    resource.dependencies = page.dependencies;
  }

  return resource;
};

const moduleItem = (module: ResourceModule): ImsItem => ({
  identifier: randomId("MODULE"),
  title: module.title,
  items: module.pages.map(
    (page): ImsItem => ({
      identifier: randomId("PAGE"),
      title: page.title,
      identifierRef: page.id,
    })
  ),
});

const nextFilePath = (
  filenames: Set<string>,
  pathPrefix: string,
  fileTitle: string,
  ext: string
): string => {
  let filePath = `${pathPrefix}_${fileTitle}.${ext}`;
  let inc = 1;
  while (filenames.has(filePath)) {
    filePath = `${pathPrefix}_${fileTitle}_${inc}.${ext}`;
    inc++;
  }
  filenames.add(filePath);

  return filePath;
};

const processContent = (
  page: Page,
  content: string,
  options?: Config
): string => {
  if (!options || page.type !== "webcontent") {
    return content;
  }

  if (
    options.cssMode === "stylesheet-tag" ||
    options.cssMode === "stylesheet-link"
  ) {
    return content;
  }

  const classes = options.classes;

  const document = new DOMParser().parseFromString(content, "text/html");

  for (const [className, style] of Object.entries(classes)) {
    const elements = document.getElementsByClassName(className);
    for (const element of elements) {
      if (options.cssMode === "inline-replace") {
        element.classList.remove(className);
      }
      const existingStyle = element.getAttribute("style") || "";
      element.setAttribute("style", `${existingStyle}${style}`);
    }
  }

  return document.documentElement.outerHTML;
};

export const packageCourse = async (
  courseContent: Course,
  generatorComment: string = "Generated by IMSCC Packager",
  version: Version = DEFAULT_VERSION,
  options?: Config
): Promise<[JSZip, string]> => {
  const zip = new JSZip();

  const modules: ResourceModule[] = [];

  const contentFiles = new Set<string>();
  const attachmentFiles = new Set<string>();
  const activityFiles = new Set<string>();

  const globalDependencies: ImsResource[] = [];
  if (options?.cssMode === "stylesheet-link") {
    const css = cssFromConfig(options);
    const path = "web_resources/styles.css";
    zip.file(path, css);
    globalDependencies.push({
      identifier: randomId("CSS"),
      type: "webcontent",
      file: {
        href: path,
      },
    });
  }

  courseContent.modules.forEach((module, i) => {
    const moduleNumber = i + 1;
    const pathPrefix = `module_${moduleNumber}`;

    modules.push({
      title: module.title,
      pages: module.pages.map((page) => {
        const id =
          page.type === "webcontent"
            ? randomId("CONTENT")
            : randomId("ACTIVITY");

        const { ext, content } = DOCUMENT_GENERATORS[page.type](
          page,
          id,
          options
        );
        const fileTitle = page.title.replace(/[^a-z0-9]/gi, "-").toLowerCase();

        const filePath =
          page.type === "webcontent"
            ? `${CONTENT_DIR}/${nextFilePath(
                contentFiles,
                pathPrefix,
                fileTitle,
                ext
              )}`
            : nextFilePath(activityFiles, pathPrefix, fileTitle, ext);

        const resourcePage: ResourcePage = {
          title: page.title,
          type: page.type,
          content: processContent(page, content, options),
          filePath,
          id,
          dependencies: globalDependencies.map((dep) => dep.identifier),
        };

        if (page.attachments) {
          const resourceAttachments = page.attachments.map(
            (attachment): ResourceAttachment => {
              if (!attachment.placeholder) {
                throw new Error("Attachment must have a placeholder property");
              }
              const placeholder = attachment.placeholder;
              const [attachmentTitle, attachmentExt] =
                attachment.filename.split(".");
              const attachmentFilePath = nextFilePath(
                attachmentFiles,
                pathPrefix,
                attachmentTitle,
                attachmentExt
              );
              const attachmentZipFilePath = `${FILES_DIR}/${attachmentFilePath}`;

              if (attachment.blob) {
                zip.file(attachmentZipFilePath, attachment.blob);
              } else if (attachment.base64) {
                zip.file(attachmentZipFilePath, attachment.base64, {
                  base64: true,
                });
              } else {
                throw new Error(
                  "Attachment must have either a blob or base64 property"
                );
              }

              resourcePage.content = resourcePage.content.replaceAll(
                placeholder,
                `${FILEBASE_PLACEHOLDER}/${attachmentFilePath}`
              );

              return {
                ...attachment,
                filePath: attachmentZipFilePath,
              };
            }
          );

          resourcePage.attachments = resourceAttachments;
        }

        zip.file(filePath, resourcePage.content);

        return resourcePage;
      }),
    });
  });

  const resourcePages: ResourcePage[] = modules.reduce(
    (acc: ResourcePage[], module) => acc.concat(module.pages),
    []
  );
  const attachmentResources: ImsResource[] = resourcePages.reduce(
    (acc: ImsResource[], page): ImsResource[] =>
      acc.concat(
        page.attachments
          ? page.attachments.map((attachment): ImsResource => {
              const id = randomId("MEDIA");

              page.dependencies = page.dependencies || [];
              page.dependencies.push(id);
              return {
                identifier: id,
                type: "webcontent",
                file: {
                  href: attachment.filePath,
                },
              };
            })
          : []
      ),
    []
  );

  const resources = resourcePages
    .map(pageResource)
    .concat(attachmentResources)
    .concat(globalDependencies);

  const manifest: ImsManifest = {
    generatorComment,
    identifier: randomId("COURSE"),
    metadata: {
      title: courseContent.title,
      description: courseContent.description,
      language: courseContent.language || "en",
      version,
    },
    organizations: [
      {
        identifier: randomId("NAV"),
        items: modules.map(moduleItem),
      },
    ],
    resources: resources,
  };

  const manifestFileContents = manifestXml(manifest);
  zip.file("imsmanifest.xml", manifestFileContents);

  return [zip, manifestFileContents];
};

export const generateImscc = async (
  course: Course,
  generatorComment?: string,
  version?: Version,
  options?: Config
): Promise<Blob> => {
  const [zip, _manifest] = await packageCourse(
    course,
    generatorComment,
    version,
    options
  );
  const zipBlob = await zip.generateAsync({ type: "blob" });
  return zipBlob;
};
